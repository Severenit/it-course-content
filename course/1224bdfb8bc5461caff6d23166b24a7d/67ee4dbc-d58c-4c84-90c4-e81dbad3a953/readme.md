
![](https://habrastorage.org/r/w1560/webt/l-/e_/52/l-e_526jgkad350tcuoiup8cm3e.png)

Node.js это — среда выполнения JavaScript. Что же это значит, и как работает?

Окружение Node.js включает все, что вам нужно для выполнения программы, написанной на JavaScript.

![](https://habrastorage.org/r/w1560/webt/dk/sq/o7/dksqo7scsztppufvmkn5yfb_cva.png)

Раньше вы могли запустить JavaScript только в браузере, но однажды разработчики расширили его, и теперь вы можете запускать JS на своем компьютере в качестве отдельного приложения. Так появился Node.js.

Теперь вы можете сделать гораздо больше с JavaScript, чем просто интерактивные веб-сайты.

Теперь у JavaScript есть возможность делать то, что могут делать другие скриптовые языки программирования, такие как Python.

Оба — браузерный JavaScript и Node.js запускаются в среде выполнения V8. Этот движок использует ваш JS код, и преобразует его в более быстрый машинный код. Машинный – низкоуровневый код, который компьютер может запускать без необходимости сначала его интерпретировать.

## **Почему Node.js?**

Вот формальное определение, данное на официальном сайте Node.js:

> — Node.js — среда выполнения JavaScript, основанная на JavaScript движке V8 из Chrome.

Мы уже обсуждали первую строку этого определения: «Node.js — среда выполнения JavaScript, основанная на JavaScript движке V8 из Chrome». Теперь давайте разбираться в двух других строках, так мы сможем понять, почему Node.js так популярен.

I/O означает ввод/вывод. Это может быть что угодно: от чтения/записи локальных файлов до HTTP-запроса в API. I/O занимает время и, следовательно, блокирует другие функции.

Рассмотрим сценарий, в котором мы запрашиваем user1 и user2 из бекенда, а затем печатаем их на экране / в консоли. Ответ на этот запрос требует времени, но оба запроса пользовательских данных могут выполняться независимо и в одно и то же время.

![](https://habrastorage.org/r/w1560/webt/cu/3j/gm/cu3jgmhfru5w50kocs-dqg8-9_k.png)

### **Блокирование ввода-вывода**

В методе блокировки запрос данных user2 не запускается до тех пор, пока данные user1 не будут напечатаны на экране.

Если это был веб-сервер, нам нужно было бы начать новый поток для каждого нового пользователя. Но JavaScript однопоточен (но он имеет однопоточный цикл событий, о котором мы поговорим чуть позже). Таким образом, это сделает JavaScript не очень подходящим для многопоточных задач.

### **Неблокирующий ввод-вывод**

С другой стороны, используя неблокирующий запрос, вы можете инициировать запрос данных для user2, не дожидаясь ответа на запрос user1. Вы можете инициировать оба запроса параллельно.

Неблокирующий ввод-вывод устраняет необходимость многопоточности, поскольку сервер может обрабатывать несколько запросов одновременно.

### **Цикл событий JavaScript**

Если у вас есть 26 минут, посмотрите отличное видео-объяснение Node Event Loop:

Если нету, вот пошаговое объяснение того, как работает Event Loop в JavaScript:

![](https://habrastorage.org/r/w1560/webt/cj/kq/jm/cjkqjmjx1su97rhpflltovmbpva.png)

1. Посылаете main() в стек вызовов.

2. Посылаете console.log() в стек вызовов. Он запускается сразу и появляется.

3. Посылаете setTimeout(2000) в стек. setTimeout(2000) это — Node API. Когда мы его вызываем, мы регистрируем пару событие-коллбек. Событие будет ждать 2000 миллисекунд, а потом вызовет коллбек.

4. После регистрации, setTimeout(2000) появляется в стеке вызовов.

5. Теперь второй setTimeout(0) регистрируется таким же образом. Теперь у нас есть два API-интерфейса Node, ожидающих выполнения.

6. После ожидания 0 секунд setTimeout(0) перемещается в очередь выполнения коллбеков (callback queue), и то же самое происходит с setTimeout(2000).

7. В очереди выполнения коллбеков функции ждут, когда стек вызовов будет пустым, потому что только одна функция может выполняться одновременно. Это обеспечивает event loop.

8. Вызывается последняя console.log(), а main() вызывается из стека вызовов.

9. Цикл событий видит, что стек вызовов пуст, а очередь обратного вызова — нет. Таким образом, он перемещает обратные вызовы (по порядку) в стек вызовов для выполнения.
